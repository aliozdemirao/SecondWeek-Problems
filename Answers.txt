------------------------------------------------- Basic types and Null Safety -------------------------------------------------

1. val ile var arasındaki fark nedir?

Kotlin'de bir değişkeni tanımlarken val ya da var anahtar kelimesini kullanırız.
val = "Yalnızca bir kez değer atanan, degeri sonradan degistirilemez, degisken" "Value" sabit kelimesinin kisaltmasidir.
var = "Değer atandıktan sonra degeri sonradan degistirilebilir, degisken" "Variable" degisken kelimesinin kisaltmasidir.
val değişkenler read-only'dir.
var değişkenler mutable'dır.

val ile var arasındaki performans farkı yok denecek kadar azdır. Genel anlamda fark etmez. 
Akademik seviyede val değişkenler var değişkenlere göre daha maliyetlidir. var, val'e göre daha performanslıdır.

Anlamak için şöyle düşünebiliriz:

val için şart koştuk:
if (değer atadıysak) {
  değerini değiştirme.
}

var için böyle bir şart yoktur.

Düz kod üzerinde akademik seviyede var kullanmak daha performanslı (göz ardı edilebilir seviyede).
Günlük hayat problemlerinde ise val kullanmak daha avantajlıdır. Kodumuz daha performanslı hale gelecektir.
Bunun sebebi ise multi thread işlemlerdir. 
Thread işlemlerin birbirleriyle olan iletişim maliyetleri bir yerden sonra çok yükselir.

Bu sebepten best practice olarak val kullanılmalıdır.

Threading işlemleri varsa val daha performanslı,
Threading işlemleri yoksa var daha performanslı olur.











2. Bir var değişkeni val gibi davranmasını nasıl sağlayabiliriz val kelimesini kullanmadan? Bunu neden yapmak isteriz? Örnek bir senaryo verin.

Her bir değişkenin biz görmesek bile arkaplanda oluşturulan get() ve set() fonksiyonları vardır.

val bir değişken oluşturulduğunda arkaplanda get() fonksiyonu,
var bir değişken için hem get() hem de set() fonksiyonları oluşturulur.

İlgili var değişkenin set() değerini private yaparsak (default public), o değişkenin değerini değiştiremez oluruz. 
Bu sayede var değişkene dışarıdan değer atanamaz hale gelir. Böylece değişkenin ilk değeri neyse sadece o alınır, sadece o korunmuş olur.

Örnek:

class Student {
    var name: String = "John"
        private set // Private setter
    fun changeName(newName: String) {
        // Bu fonksiyon name özelliğine erişebilir ve bu özelliği değiştirebilir
        name = newName
    }
}
fun main() {
    val student = Student()
    println("Original Name: ${student.name}")
    // setter private olduğu için bu kod bir derleme hatasına (compilation error) neden olur.
    // student.name = "Alice"
    // name'i değiştirmek için changeName fonksiyonunu kullanın.
    student.changeName("Alice")
    println("Updated Name: ${student.name}")
}

Bu örnekte: 
Student class'ının private setter'ı olan bir name property'si vardır. Bu, external kodun (class'ın dışında) name özelliğinin değerini doğrudan ayarlayamayacağı anlamına gelir.
Bunun yerine, name özelliğini değiştirmenize olanak tanıyan bir (public) changeName(newName: String) fonksiyonu sağlıyoruz. Bu fonksiyon aynı class içinde olduğu için name özelliğine erişebilir ve onu değiştirebilir.
main fonksiyonunda, bir Student nesnesi oluşturuyoruz ve başlangıçta, setter private olduğu için name özelliğini doğrudan ayarlayamıyoruz. Bunun yerine, name özelliğini güncellemek için changeName fonksiyonunu kullanırız.












3. "Değişmez" (Immutable) ve "Salt Okunur" (ReadOnly) kavramlarını açıklayın. val değişkenler neden aslında "değişmez" değil de "salt okunur" olarak açıklanmalıdır?

immutable -> değeri hiçbir şekilde değişemez değişkendir.
read-only -> değeri okunabilen (değişemez anlamına gelmez), set edilemeyen değişkendir. Sadece değeri okunabilir, değer atanamaz. Dolayısıyla okunabilir olan değer, değiştirilebilir.

val değişkenler read-only'dir.

Bir class'ın içerisindeki bir değişkene val olsa bile get() fonksiyonu üzerinden return ettiği değeri değiştirebiliriz. Bu sebeple val değişkenler immutable değildir!

Örnek:

class Box {
    var width: Int = 20
    var height: Int = 40
    var length: Int = 50
    var usedSpace: Int = 0

    val availableSpace: Int
        get() {
            return (width * height * length) - usedSpace // Degiskenin degeri, buradaki ozelliklere gore degisebilir. Bu sebeple val degiskenler immutable degil, read only'dir.
        }
}

fun calculateAvailableSpace() {
    val box = Box()
    box.height = 10
    box.width = 20
    box.length = 5
    box.usedSpace = 2
    println(box.availableSpace)

    box.height = 30
    box.width = 10
    box.length = 8
    box.usedSpace = 0
    println(box.availableSpace)
}

fun main() {
    calculateAvailableSpace()
}












4. "Tip Çıkarımı" (Type inference) kavramını açıklayın. Hangi durumlarda tip belirtmek kesin olarak gereklidir?

Type Inference: Kotlin'de bir değişkenin türünü açık bir şekilde (Explicitly) belirtmek zorunda olmadan, derleyicinin değişkenin türünü otomatik olarak çıkarmasını sağlayan bir özelliktir.

Kotlin, derleme zamanı (compile-time) tip bilgisi için bir tip çıkarımı kavramına sahiptir, yani koddaki bazı tür bilgileri derleyici tarafından çıkarılmak üzere atlanabilir. 
Kotlin tarafından desteklenen iki tür tür çıkarımı vardır:

1- Local type inference, expressions'ların tiplerini local olarak, statement/expression scope'unda çıkarmak için;
2- Function signature type inference, fonksiyon return değerlerinin ve/veya parametrelerinin tiplerinin çıkarılması için.


Nullable: Bir degiskene null deger atamasi yapabilmek icin tipinin sonuna ? isareti konur.
	
Eger bir degiskene tip verilmez ve direkt null deger atamasi yapilirsa, IDE tip cikarimi yaparken,
bu degiskenin tipini Nothing? olarak isaretler. Cunku hangi tipe karsilik geldigini bilemez.
Nothing -> içi bomboş bir class.


Değişkeni tanımlayıp daha sonra atama işlemi yapacaksak tipini belirtmemiz gerekir.


Number'lar için dikkat etmemiz gereken bir nokta var:
Eğer değişkenin değeri Int aralığında olursa tür otomatik olarak Int olarak belirleniyor. Int olmasını istemiyorsak, ilgili aralığa göre tipini belirtmemiz gerekir.
Eğer değişkenin değeri Int aralığında olmazsa tür otomatik olarak Long olarak belirleniyor.












5. Kotlin'de tüm değişkenlerin sınıf olarak bulunması, "ilkel tip" (primitive type) olmadıkları anlamına gelir mi? Arka planda neler oluyor?

Değişkenler ikiye ayrılır:
1- Referans Tipli (Boxed)
2- Primitive Tipli (Unboxed)

Primitive Tipler, hem kapladıkları alan bakımından hem de erişim hızları bakımından Referans tipli değişkenlere göre çok daha hızlı çalışan değişken tipleridir.

Kotlin'de Primitive tipler birer class gibi görünürler. Runtime'da class olmayan primitive hallerine optimize edilirler. Java'daki Primitive tiplere karşılık geliyor.
String hariç. String, Java tarafında da class halinde tutulur. Bu durumu Show Kotlin Bytecode ile inceleyebiliriz.

Primitive tipli değişkenler şöyle davranır: var age: Int = 30	// Java'daki int tipine denk gelir.
Stack'te hem değişkenin kendisi hem de değeri için yer ayrılır.

Referans tipli değişkenler şöyle davranır: var age: Int? = 30	// Java'daki Integer tipine denk gelir.
Değişkenin adı Stack'te değeri Heap'te tutulur.












6. "Tip Güvenliği" (Type Safety) kavramını açıklayın.

Tip güvenliği (Type Safety), bir programlama dilinde belirli bir türün yanlışlıkla başka bir türe dönüştürülmesini önlemeyi amaçlayan bir kavramdır.
Bu kavram, tür uyumsuzluklarından kaynaklanan hataları azaltarak kodun daha güvenilir olmasını sağlar.

Örneğin, Kotlin'de bir değişkenin int türünde olduğunu belirttiğinizde, o değişkene sadece tamsayı değerleri atanabilir ve diğer türlerden gelen değerler kabul edilmez. 
Bu, tip güvenliği sağlayan bir özelliktir çünkü programın çalışma zamanında (run time) beklenmeyen tür dönüşümleri veya hatalı tür atamaları olasılığını azaltır.

Kotlin gibi modern programlama dilleri, tip güvenliğini desteklemek için derleme zamanında (Compile time) tür denetimlerini yapar ve kodun daha sağlam olmasını sağlar. 
Bu sayede programcılar, hataları daha erken aşamalarda tespit edebilir ve daha güvenilir yazılımlar geliştirebilir.











7. Bir değişkeni nullable yapmak için ne yapmalıyız?

Bir değişkeni nullable yapmak için "?" işaretini kullanarak belirtilen bir türü "nullable" hale getirebiliriz. Bu işaret, o değişkenin null değerini kabul edebileceğini belirtir.

var nullableInt: Int? = null
nullableInt = 10











8. "Null Güvenliği" (Null Safety) kavramını açıklayın.

Elimizde nullable bir değişken varsa ve bu degiskenin methodlarindan birine ihtiyaç duyacaksak ya da direkt olarak kullanacaksak, 
bu durumda IDE'ye ya bu degiskenin null olmayacaginin garantisi !! operatoru ile vermek gerekiyor ya da null degilse çalışsın demek için ?. operatorunu kullanmak gerekiyor.

Best Practice olarak kodlarimizi !! seklinde yazmamiz Kotlin Null Pointer Exception hatasi almamizi saglar.

Bu sayede gozden kaçan nullable degerleri bulabilmemizi saglar.
Ancak, canliya cikan projemizde, cok gerekli olmayan kisimlar icin, daha az onemli olan kisimlar icin ?. 
daha onemli, kritik kısımlar icin !! kullanmaliyiz.

Ornek:
1- Bankacılık uygulamasında kullanıcının balance değeri yanlış gelecekse ->  !! kullan. kritik hata.
2- Bankacılık uygulamasında karşılama ekranında hoşgeldiniz ad_soyad. -> ?. kullan. kritik hata değil.











9. Bir değişkene null değer atanır ve tip belirtilmezse Kotlin bu değişkeni nasıl yorumlar?

Eger bir degiskene tip verilmez ve direkt null deger atamasi yapilirsa, IDE Tip Çıkarımı (Type Inference) yaparken bu degiskenin tipini Nothing? olarak isaretler. 
Cunku hangi tipe karsilik geldigini bilemez.

val number1 = null		// (Type: Nothing? olarak belirlendi)
val number2: Nothing? = null	

Nothing içi bomboş bir classtır.
Bir fonksiyonun, herhangi bir değer döndürmek zorunda olmadığı durumlarda kullanılır.
Genellikle Exception fırlatmalarda görülür.

Unit'ten farklıdır. Unit, boş da olsa bir değer döndüğünü söyler. Nothing hiçbir şey değil.
Unit -> "", Nothing -> null gibi düşünebiliriz.











10. İlkel bir değişkenin nullable olması ile null değer alamaması arasında bellek yönetimi açısından nasıl farklar vardır?

Eğer bir primitive type değişken nullable olarak işaretlendi ise o değişken artık primitive olarak değil reference type bir nesne olarak temsil edilecektir.

Stack ve Heap denen 2 adet memory alanımız vardır. Stack ve Heap.

Biz bir primitive tipli (unboxed) değişken oluşturduğumuz zaman hem değişkenin kendisi hem de değeri için stackde yer ayrılır.
val age: Int = 30
Bu ikisi toplamda bir Int kadar yer kaplar. Stack alanı, Heap alanından daha hızlı çalışır.

Eğer referans tipli (boxed) bir değişkenle çalışıyorsak, o değişkenin ismi Stack'de tutulur, değeri Heap'de tutulur.
val age: Int? = 30
age'in kendisi Stack'de tutulur. İçerdiği değer ise Heap'de tutulur.

Eğer bu değişkene null değerini verirsek, heapde kullandığı alan boşalır fakat stackde değişkenin ismi için yer kaplanmaya devam edilir.
Dolayısıyla, değişkeni null'lamamız, değişken için memory'de herhangi bir alan tutulmuyor anlamına gelmez.
Değişkenin kendisi için bir alan tutulur fakat değeri için bir alan tutulmuyor anlamına gelir.
Sonrasında bir değer atarsak, heapde değişkenin değeri, stack'de ise değişkenin kendisi tutulmaya devam edilir.