------------------------------------------------- Basic types and Null Safety -------------------------------------------------

1. val ile var arasındaki fark nedir?

Kotlin'de bir değişkeni tanımlarken val ya da var anahtar kelimesini kullanırız.
val = "Yalnızca bir kez değer atanan, degeri sonradan degistirilemez, degisken" "Value" sabit kelimesinin kisaltmasidir.
var = "Değer atandıktan sonra degeri sonradan degistirilebilir, degisken" "Variable" degisken kelimesinin kisaltmasidir.
val değişkenler read-only'dir.
var değişkenler mutable'dır.

val ile var arasındaki performans farkı yok denecek kadar azdır. Genel anlamda fark etmez. 
Akademik seviyede val değişkenler var değişkenlere göre daha maliyetlidir. var, val'e göre daha performanslıdır.

Anlamak için şöyle düşünebiliriz:

val için şart koştuk:
if (değer atadıysak) {
  değerini değiştirme.
}

var için böyle bir şart yoktur.

Düz kod üzerinde akademik seviyede var kullanmak daha performanslı (göz ardı edilebilir seviyede).
Günlük hayat problemlerinde ise val kullanmak daha avantajlıdır. Kodumuz daha performanslı hale gelecektir.
Bunun sebebi ise multi thread işlemlerdir. 
Thread işlemlerin birbirleriyle olan iletişim maliyetleri bir yerden sonra çok yükselir.

Bu sebepten best practice olarak val kullanılmalıdır.

Threading işlemleri varsa val daha performanslı,
Threading işlemleri yoksa var daha performanslı olur.











2. Bir var değişkeni val gibi davranmasını nasıl sağlayabiliriz val kelimesini kullanmadan? Bunu neden yapmak isteriz? Örnek bir senaryo verin.

Her bir değişkenin biz görmesek bile arkaplanda oluşturulan get() ve set() fonksiyonları vardır.

val bir değişken oluşturulduğunda arkaplanda get() fonksiyonu,
var bir değişken için hem get() hem de set() fonksiyonları oluşturulur.

İlgili var değişkenin set() değerini private yaparsak (default public), o değişkenin değerini değiştiremez oluruz. 
Bu sayede var değişkene dışarıdan değer atanamaz hale gelir. Böylece değişkenin ilk değeri neyse sadece o alınır, sadece o korunmuş olur.

Örnek:

class Student {
    var name: String = "John"
        private set // Private setter
    fun changeName(newName: String) {
        // Bu fonksiyon name özelliğine erişebilir ve bu özelliği değiştirebilir
        name = newName
    }
}
fun main() {
    val student = Student()
    println("Original Name: ${student.name}")
    // setter private olduğu için bu kod bir derleme hatasına (compilation error) neden olur.
    // student.name = "Alice"
    // name'i değiştirmek için changeName fonksiyonunu kullanın.
    student.changeName("Alice")
    println("Updated Name: ${student.name}")
}

Bu örnekte: 
Student class'ının private setter'ı olan bir name property'si vardır. Bu, external kodun (class'ın dışında) name özelliğinin değerini doğrudan ayarlayamayacağı anlamına gelir.
Bunun yerine, name özelliğini değiştirmenize olanak tanıyan bir (public) changeName(newName: String) fonksiyonu sağlıyoruz. Bu fonksiyon aynı class içinde olduğu için name özelliğine erişebilir ve onu değiştirebilir.
main fonksiyonunda, bir Student nesnesi oluşturuyoruz ve başlangıçta, setter private olduğu için name özelliğini doğrudan ayarlayamıyoruz. Bunun yerine, name özelliğini güncellemek için changeName fonksiyonunu kullanırız.












3. "Değişmez" (Immutable) ve "Salt Okunur" (ReadOnly) kavramlarını açıklayın. val değişkenler neden aslında "değişmez" değil de "salt okunur" olarak açıklanmalıdır?

immutable -> değeri hiçbir şekilde değişemez değişkendir.
read-only -> değeri okunabilen (değişemez anlamına gelmez), set edilemeyen değişkendir. Sadece değeri okunabilir, değer atanamaz. Dolayısıyla okunabilir olan değer, değiştirilebilir.

val değişkenler read-only'dir.

Bir class'ın içerisindeki bir değişkene val olsa bile get() fonksiyonu üzerinden return ettiği değeri değiştirebiliriz. Bu sebeple val değişkenler immutable değildir!

Örnek:

class Box {
    var width: Int = 20
    var height: Int = 40
    var length: Int = 50
    var usedSpace: Int = 0

    val availableSpace: Int
        get() {
            return (width * height * length) - usedSpace // Degiskenin degeri, buradaki ozelliklere gore degisebilir. Bu sebeple val degiskenler immutable degil, read only'dir.
        }
}

fun calculateAvailableSpace() {
    val box = Box()
    box.height = 10
    box.width = 20
    box.length = 5
    box.usedSpace = 2
    println(box.availableSpace)

    box.height = 30
    box.width = 10
    box.length = 8
    box.usedSpace = 0
    println(box.availableSpace)
}

fun main() {
    calculateAvailableSpace()
}