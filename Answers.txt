------------------------------------------------- Basic types and Null Safety -------------------------------------------------

1. val ile var arasındaki fark nedir?

Kotlin'de bir değişkeni tanımlarken val ya da var anahtar kelimesini kullanırız.
val = "Yalnızca bir kez değer atanan, degeri sonradan degistirilemez, degisken" "Value" sabit kelimesinin kisaltmasidir.
var = "Değer atandıktan sonra degeri sonradan degistirilebilir, degisken" "Variable" degisken kelimesinin kisaltmasidir.
val değişkenler read-only'dir.
var değişkenler mutable'dır.

val ile var arasındaki performans farkı yok denecek kadar azdır. Genel anlamda fark etmez. 
Akademik seviyede val değişkenler var değişkenlere göre daha maliyetlidir. var, val'e göre daha performanslıdır.

Anlamak için şöyle düşünebiliriz:

val için şart koştuk:
if (değer atadıysak) {
  değerini değiştirme.
}

var için böyle bir şart yoktur.

Düz kod üzerinde akademik seviyede var kullanmak daha performanslı (göz ardı edilebilir seviyede).
Günlük hayat problemlerinde ise val kullanmak daha avantajlıdır. Kodumuz daha performanslı hale gelecektir.
Bunun sebebi ise multi thread işlemlerdir. 
Thread işlemlerin birbirleriyle olan iletişim maliyetleri bir yerden sonra çok yükselir.

Bu sebepten best practice olarak val kullanılmalıdır.

Threading işlemleri varsa val daha performanslı,
Threading işlemleri yoksa var daha performanslı olur.











2. Bir var değişkeni val gibi davranmasını nasıl sağlayabiliriz val kelimesini kullanmadan? Bunu neden yapmak isteriz? Örnek bir senaryo verin.

Her bir değişkenin biz görmesek bile arkaplanda oluşturulan get() ve set() fonksiyonları vardır.

val bir değişken oluşturulduğunda arkaplanda get() fonksiyonu,
var bir değişken için hem get() hem de set() fonksiyonları oluşturulur.

İlgili var değişkenin set() değerini private yaparsak (default public), o değişkenin değerini değiştiremez oluruz. 
Bu sayede var değişkene dışarıdan değer atanamaz hale gelir. Böylece değişkenin ilk değeri neyse sadece o alınır, sadece o korunmuş olur.

Örnek:

class Student {
    var name: String = "John"
        private set // Private setter
    fun changeName(newName: String) {
        // Bu fonksiyon name özelliğine erişebilir ve bu özelliği değiştirebilir
        name = newName
    }
}
fun main() {
    val student = Student()
    println("Original Name: ${student.name}")
    // setter private olduğu için bu kod bir derleme hatasına (compilation error) neden olur.
    // student.name = "Alice"
    // name'i değiştirmek için changeName fonksiyonunu kullanın.
    student.changeName("Alice")
    println("Updated Name: ${student.name}")
}

Bu örnekte: 
Student class'ının private setter'ı olan bir name property'si vardır. Bu, external kodun (class'ın dışında) name özelliğinin değerini doğrudan ayarlayamayacağı anlamına gelir.
Bunun yerine, name özelliğini değiştirmenize olanak tanıyan bir (public) changeName(newName: String) fonksiyonu sağlıyoruz. Bu fonksiyon aynı class içinde olduğu için name özelliğine erişebilir ve onu değiştirebilir.
main fonksiyonunda, bir Student nesnesi oluşturuyoruz ve başlangıçta, setter private olduğu için name özelliğini doğrudan ayarlayamıyoruz. Bunun yerine, name özelliğini güncellemek için changeName fonksiyonunu kullanırız.












3. "Değişmez" (Immutable) ve "Salt Okunur" (ReadOnly) kavramlarını açıklayın. val değişkenler neden aslında "değişmez" değil de "salt okunur" olarak açıklanmalıdır?

immutable -> değeri hiçbir şekilde değişemez değişkendir.
read-only -> değeri okunabilen (değişemez anlamına gelmez), set edilemeyen değişkendir. Sadece değeri okunabilir, değer atanamaz. Dolayısıyla okunabilir olan değer, değiştirilebilir.

val değişkenler read-only'dir.

Bir class'ın içerisindeki bir değişkene val olsa bile get() fonksiyonu üzerinden return ettiği değeri değiştirebiliriz. Bu sebeple val değişkenler immutable değildir!

Örnek:

class Box {
    var width: Int = 20
    var height: Int = 40
    var length: Int = 50
    var usedSpace: Int = 0

    val availableSpace: Int
        get() {
            return (width * height * length) - usedSpace // Degiskenin degeri, buradaki ozelliklere gore degisebilir. Bu sebeple val degiskenler immutable degil, read only'dir.
        }
}

fun calculateAvailableSpace() {
    val box = Box()
    box.height = 10
    box.width = 20
    box.length = 5
    box.usedSpace = 2
    println(box.availableSpace)

    box.height = 30
    box.width = 10
    box.length = 8
    box.usedSpace = 0
    println(box.availableSpace)
}

fun main() {
    calculateAvailableSpace()
}












4. "Tip Çıkarımı" (Type inference) kavramını açıklayın. Hangi durumlarda tip belirtmek kesin olarak gereklidir?

Type Inference: Kotlin'de bir değişkenin türünü açık bir şekilde (Explicitly) belirtmek zorunda olmadan, derleyicinin değişkenin türünü otomatik olarak çıkarmasını sağlayan bir özelliktir.

Kotlin, derleme zamanı (compile-time) tip bilgisi için bir tip çıkarımı kavramına sahiptir, yani koddaki bazı tür bilgileri derleyici tarafından çıkarılmak üzere atlanabilir. 
Kotlin tarafından desteklenen iki tür tür çıkarımı vardır:

1- Local type inference, expressions'ların tiplerini local olarak, statement/expression scope'unda çıkarmak için;
2- Function signature type inference, fonksiyon return değerlerinin ve/veya parametrelerinin tiplerinin çıkarılması için.


Nullable: Bir degiskene null deger atamasi yapabilmek icin tipinin sonuna ? isareti konur.
	
Eger bir degiskene tip verilmez ve direkt null deger atamasi yapilirsa, IDE tip cikarimi yaparken,
bu degiskenin tipini Nothing? olarak isaretler. Cunku hangi tipe karsilik geldigini bilemez.
Nothing -> içi bomboş bir class.


Değişkeni tanımlayıp daha sonra atama işlemi yapacaksak tipini belirtmemiz gerekir.


Number'lar için dikkat etmemiz gereken bir nokta var:
Eğer değişkenin değeri Int aralığında olursa tür otomatik olarak Int olarak belirleniyor. Int olmasını istemiyorsak, ilgili aralığa göre tipini belirtmemiz gerekir.
Eğer değişkenin değeri Int aralığında olmazsa tür otomatik olarak Long olarak belirleniyor.












5. Kotlin'de tüm değişkenlerin sınıf olarak bulunması, "ilkel tip" (primitive type) olmadıkları anlamına gelir mi? Arka planda neler oluyor?

Değişkenler ikiye ayrılır:
1- Referans Tipli (Boxed)
2- Primitive Tipli (Unboxed)

Primitive Tipler, hem kapladıkları alan bakımından hem de erişim hızları bakımından Referans tipli değişkenlere göre çok daha hızlı çalışan değişken tipleridir.

Kotlin'de Primitive tipler birer class gibi görünürler. Runtime'da class olmayan primitive hallerine optimize edilirler. Java'daki Primitive tiplere karşılık geliyor.
String hariç. String, Java tarafında da class halinde tutulur. Bu durumu Show Kotlin Bytecode ile inceleyebiliriz.

Primitive tipli değişkenler şöyle davranır: var age: Int = 30	// Java'daki int tipine denk gelir.
Stack'te hem değişkenin kendisi hem de değeri için yer ayrılır.

Referans tipli değişkenler şöyle davranır: var age: Int? = 30	// Java'daki Integer tipine denk gelir.
Değişkenin adı Stack'te değeri Heap'te tutulur.












6. "Tip Güvenliği" (Type Safety) kavramını açıklayın.

Tip güvenliği (Type Safety), bir programlama dilinde belirli bir türün yanlışlıkla başka bir türe dönüştürülmesini önlemeyi amaçlayan bir kavramdır.
Bu kavram, tür uyumsuzluklarından kaynaklanan hataları azaltarak kodun daha güvenilir olmasını sağlar.

Örneğin, Kotlin'de bir değişkenin int türünde olduğunu belirttiğinizde, o değişkene sadece tamsayı değerleri atanabilir ve diğer türlerden gelen değerler kabul edilmez. 
Bu, tip güvenliği sağlayan bir özelliktir çünkü programın çalışma zamanında (run time) beklenmeyen tür dönüşümleri veya hatalı tür atamaları olasılığını azaltır.

Kotlin gibi modern programlama dilleri, tip güvenliğini desteklemek için derleme zamanında (Compile time) tür denetimlerini yapar ve kodun daha sağlam olmasını sağlar. 
Bu sayede programcılar, hataları daha erken aşamalarda tespit edebilir ve daha güvenilir yazılımlar geliştirebilir.











7. Bir değişkeni nullable yapmak için ne yapmalıyız?

Bir değişkeni nullable yapmak için "?" işaretini kullanarak belirtilen bir türü "nullable" hale getirebiliriz. Bu işaret, o değişkenin null değerini kabul edebileceğini belirtir.

var nullableInt: Int? = null
nullableInt = 10











8. "Null Güvenliği" (Null Safety) kavramını açıklayın.

Elimizde nullable bir değişken varsa ve bu degiskenin methodlarindan birine ihtiyaç duyacaksak ya da direkt olarak kullanacaksak, 
bu durumda IDE'ye ya bu degiskenin null olmayacaginin garantisi !! operatoru ile vermek gerekiyor ya da null degilse çalışsın demek için ?. operatorunu kullanmak gerekiyor.

Best Practice olarak kodlarimizi !! seklinde yazmamiz Kotlin Null Pointer Exception hatasi almamizi saglar.

Bu sayede gozden kaçan nullable degerleri bulabilmemizi saglar.
Ancak, canliya cikan projemizde, cok gerekli olmayan kisimlar icin, daha az onemli olan kisimlar icin ?. 
daha onemli, kritik kısımlar icin !! kullanmaliyiz.

Ornek:
1- Bankacılık uygulamasında kullanıcının balance değeri yanlış gelecekse ->  !! kullan. kritik hata.
2- Bankacılık uygulamasında karşılama ekranında hoşgeldiniz ad_soyad. -> ?. kullan. kritik hata değil.











9. Bir değişkene null değer atanır ve tip belirtilmezse Kotlin bu değişkeni nasıl yorumlar?

Eger bir degiskene tip verilmez ve direkt null deger atamasi yapilirsa, IDE Tip Çıkarımı (Type Inference) yaparken bu degiskenin tipini Nothing? olarak isaretler. 
Cunku hangi tipe karsilik geldigini bilemez.

val number1 = null		// (Type: Nothing? olarak belirlendi)
val number2: Nothing? = null	

Nothing içi bomboş bir classtır.
Bir fonksiyonun, herhangi bir değer döndürmek zorunda olmadığı durumlarda kullanılır.
Genellikle Exception fırlatmalarda görülür.

Unit'ten farklıdır. Unit, boş da olsa bir değer döndüğünü söyler. Nothing hiçbir şey değil.
Unit -> "", Nothing -> null gibi düşünebiliriz.











10. İlkel bir değişkenin nullable olması ile null değer alamaması arasında bellek yönetimi açısından nasıl farklar vardır?

Eğer bir primitive type değişken nullable olarak işaretlendi ise o değişken artık primitive olarak değil reference type bir nesne olarak temsil edilecektir.

Stack ve Heap denen 2 adet memory alanımız vardır. Stack ve Heap.

Biz bir primitive tipli (unboxed) değişken oluşturduğumuz zaman hem değişkenin kendisi hem de değeri için stackde yer ayrılır.
val age: Int = 30
Bu ikisi toplamda bir Int kadar yer kaplar. Stack alanı, Heap alanından daha hızlı çalışır.

Eğer referans tipli (boxed) bir değişkenle çalışıyorsak, o değişkenin ismi Stack'de tutulur, değeri Heap'de tutulur.
val age: Int? = 30
age'in kendisi Stack'de tutulur. İçerdiği değer ise Heap'de tutulur.

Eğer bu değişkene null değerini verirsek, heapde kullandığı alan boşalır fakat stackde değişkenin ismi için yer kaplanmaya devam edilir.
Dolayısıyla, değişkeni null'lamamız, değişken için memory'de herhangi bir alan tutulmuyor anlamına gelmez.
Değişkenin kendisi için bir alan tutulur fakat değeri için bir alan tutulmuyor anlamına gelir.
Sonrasında bir değer atarsak, heapde değişkenin değeri, stack'de ise değişkenin kendisi tutulmaya devam edilir.











11. Nullable bir değişkenin bir değere sahip olması ile null olması arasında bellek yönetimi açısından nasıl bir fark vardır? Null değer almış bir değişken bellekte yer kaplamaz diyebilir miyiz?

JVM based programlama dillerinde bizim çok fazla bellek yönetimi yapma ihtiyacımız olmuyor. 
Low level dillerde özellikle referans tipli değişkenlerde işleri bitince null'lamaları gerekiyor.
Kotlinde de kullanmadığımız ve fazlaca yer kaplayan yapıları, büyük nesneleri null'layabiliriz.

Nullable olan değişkenler Referans tiplidirler. 
Böyle değişkenlere null değerini verirsek, heapde kullandığı alan boşalır fakat stackde değişkenin ismi için yer kaplanmaya devam edilir.
Dolayısıyla, değişkeni null'lamamız, değişken için memory'de herhangi bir alan tutulmuyor anlamına gelmez.
Değişkenin kendisi için bir alan tutulur fakat değeri için bir alan tutulmuyor anlamına gelir.
Sonrasında bir değer atarsak, heapde değişkenin değeri, stack'de ise değişkenin kendisi tutulmaya devam edilir.











12. Nullable bir değişkenle çalışırken hangi operatörleri kullanırız? Bu operatörlerin kullanım farkları nelerdir? Hangisini ne zaman kullanmak daha anlamlıdır?

?. (safe call operatörü) ve !!. (non-null assertion operatörü) 8. soruda cevaplandı.

?: (elvis operatörü):
	Nullable bir değişkenin null olması durumunda varsayılan bir değer belirlemek için kullanılır.
	Eğer değişken null ise, belirtilen varsayılan değer döndürülür.
	Örneğin: val length = nullableVariable?.length ?: 0

Hangi operatörün kullanılacağı durum, kullanım senaryosuna bağlıdır:
Ornek:
1- Bankacılık uygulamasında kullanıcının balance değeri yanlış gelecekse ->  !! kullan. kritik hata.
2- Bankacılık uygulamasında karşılama ekranında hoşgeldiniz ad_soyad. -> ?. kullan. kritik hata değil.










------------------------------------------------- Numbers -------------------------------------------------

1. Kaç farklı tipte "number" sınıfı miras alan "alt sınıf" (child class) vardır? Bunların değer aralıkları neden önemlidir?

Byte, Short, Int, Long, Float ve Double olmak üzere 6 child class, Number class'ını miras almaktadır.

Değer aralıkları, seçilecek veri tipinin bellek kullanımı ve performans açısından uygunluğunu belirler. 
Doğru veri tipini seçmek, uygulamanın daha verimli çalışmasını sağlar ve gereksiz bellek kullanımını önler.
Ayrıca, belirli bir değer aralığını aşmayan sayılar için daha küçük veri tipleri kullanmak, bellek tasarrufu sağlar ve bellek erişim hızını artırır.










2. Eğer bir değişkene tip belirtimi yapılmaz ve bir değer atanırsa, Kotlin tip çıkarımını nasıl yapar?

Kotlin'de, bir değişkene tip belirtimi yapılmazsa ve bir değer atanırsa, Kotlin derleyicisi otomatik olarak tip çıkarımı (type inference) yapar. 
Tip çıkarımı, atanan değere bakarak değişkenin türünü belirleme sürecidir.

Type Inference sırasında eğer sayı Int aralığında ise, tipi default olarak Int set edilir.
Type Inference sırasında eğer sayı Int aralığında değilse, tipi default olarak Long set edilir.










3. Float değişken oluştururken F ve f harfleri varken, Long değişken oluştururken neden küçük l harfi yoktur?

Küçük l harfi, bazı yazı tiplerinde rakam olan 1 (bir) ile karışabilir. Bu, kodun okunabilirliğini azaltır ve potansiyel olarak hata yapma riskini artırır. Bu sebeple 'l' harfi kullanılmaz.










4. Tek duyarlıklı (Single precision) ve Çift duyarlıklı (Double precision) kavramlarını açıklayın.

Kotlin'de Tek Duyarlıklı (Single Precision) - Float ve Çift Duyarlıklı (Double Precision) Double veri tipleri, farklı hassasiyet ve bellek kullanım gereksinimlerine göre seçilir. 
Float daha az bellek kullanımı ve yeterli hassasiyet gerektiren durumlar için uygundur, Double ise yüksek hassasiyet ve geniş değer aralığı gerektiren durumlar için tercih edilir. 

Type		Size (bits)	Significant bits	Exponent bits	Decimal digits
Float		32		24			8		6-7
Double		64		53			11		15-16










5. Double ve Float değişkenlerle çalışırken ondalık ayıracı olarak hangi işaretler kullanılır? Bu ayıraçların kullanımında nelere dikkat etmek gerekir?

Kotlin'de Double ve Float değişkenlerle çalışırken ondalık ayıracı olarak nokta (.) kullanılır. Bu, sayının tam kısmı ile kesirli kısmını ayıran standart bir işarettir.

val doubleNumber: Double = 3.141592653589793
val floatNumber: Float = 2.71828f

Farklı diller ve yerel ayarlarda ondalık ayıracı olarak virgül (,) kullanılabilir. Bu durumlarda kullanıcılardan input alırken virgülü noktaya çevirmek önemlidir.










6. Double ve Float değişkenler ondalık kısımda kaç basamağa kadar işlem yaparlar? Bu sınırın üzerinde gelen ondalık bilgileri için nasıl davranırlar? Hangi durumlar için Float ve hangi durumlar için Double kullanılmalıdır?

Type		Size (bits)	Decimal digits
Float		32		6-7
Double		64		15-16


val floatNumberWithExtraPrecision: Float = 1.123456789f
println(floatNumberWithExtraPrecision) // Çıktı: 1.1234568

Bu örnekte, floatNumberWithExtraPrecision değişkeninde, 7. basamaktan sonrası yuvarlanır.


val doubleNumberWithExtraPrecision: Double = 1.12345678901234567890
println(doubleNumberWithExtraPrecision) // Çıktı: 1.1234567890123457

Bu örnekte, doubleNumberWithExtraPrecision değişkeninde, 16. basamaktan sonrası yuvarlanır.


Float daha az bellek kullanır ve genellikle hassasiyetin çok kritik olmadığı durumlarda tercih edilir:
	Grafik işlemleri ve oyun geliştirme
	Sensör verileri ve gerçek zamanlı sistemler
	Bellek kullanımının kısıtlı olduğu gömülü sistemler

Double daha yüksek hassasiyet sağlar ve genellikle hassas hesaplamaların gerektiği durumlarda tercih edilir:
	Finansal hesaplamalar
	Bilimsel araştırmalar ve mühendislik hesaplamaları
	Veri analizi ve yüksek hassasiyet gerektiren matematiksel işlemler










7. Ondalık(Decimal), Onaltılık (Hexadecimal) ve İkilik (Binary) değişkenleri Kotlin'de nasıl tanımlayabilirsiniz?

Ondalık (Decimal) sayılar, en yaygın kullanılan sayısal sistemdir ve varsayılan olarak herhangi bir sayı ondalık sistemde kabul edilir. Ondalık sayılar doğrudan yazılır:

val decimalInt: Int = 42
val decimalDouble: Double = 3.14159


Onaltılık (Hexadecimal) sayılar, 0x veya 0X ön eki ile belirtilir. 0-9 arası rakamlar ve A-F (veya a-f) harfleri kullanılarak temsil edilir.

val hexInt: Int = 0x2A // 42'nin onaltılık gösterimi
val hexLong: Long = 0x2AL // 42'nin onaltılık gösterimi, Long tipi


İkilik (Binary) sayılar, 0b veya 0B ön eki ile belirtilir. Sadece 0 ve 1 rakamları kullanılır.

val binaryInt: Int = 0b101010 // 42'nin ikilik gösterimi
val binaryLong: Long = 0b101010L // 42'nin ikilik gösterimi, Long tipi










8. Sekizlik (Octal) değişkenler Java'da nasıl tanımlanır? Kotlin'de Sekizlik değişken tanımlanabilir mi?

Java'da sekizlik (octal) sayılar, 0 ön eki kullanılarak tanımlanır. Bu sayılar 0-7 arasındaki rakamları kullanır.

int octalNumber = 052; // 52 sekizlik sistemde, 42 ondalık sistemde
System.out.println(octalNumber); // Çıktı: 42


Kotlin, doğrudan sekizlik (octal) sayı sistemi için bir sözdizimi (syntax) sağlamaz. Yani, Java'da olduğu gibi 0 ön ekini kullanarak sekizlik sayıları Kotlin'de tanımlayamazsınız.
Sekizlik sayıları ondalık sayılara dönüştürerek kullanabilirsiniz:

val octalString = "52"
val decimalValue = octalString.toInt(8)
println(decimalValue) // Çıktı: 42










9. "Geleneksel Notasyon" (Conventional Notation) gösterimi nasıl yapılır?

Kotlin'de "Geleneksel Notasyon" (Conventional Notation), özellikle bilimsel ve mühendislik hesaplamalarında yaygın olarak kullanılan bir yöntemdir. 
Bu notasyon, sayıları çok büyük veya çok küçük değerlerle ifade etmek için kullanılır. 
Geleneksel notasyon, Kotlin'de ve birçok diğer programlama dilinde e-notation olarak bilinir ve sayıları 10'un kuvvetleri şeklinde ifade eder.

Geleneksel notasyon, e veya E karakteri ile kullanılır ve bu karakter, 10'un kuvvetini belirtir. Bu notasyon, Double ve Float veri tipleriyle birlikte kullanılır.

val largeDoubleNumber: Double = 1.23e10
println(largeDoubleNumber) // Çıktı: 1.23 * 10^10 yani 12300000000.0

val smallDoubleNumber: Double = 1.23e-10
println(smallDoubleNumber) // Çıktı: 1.23 * 10^-10 yani 0.000000000123

val largeFloatNumber: Float = 1.23e10f
println(largeFloatNumber) // Çıktı: 1.23 * 10^10 yani 12300000000.0

val smallFloatNumber: Float = 1.23e-10f
println(smallFloatNumber) // Çıktı: 1.23 * 10^-10 yani 0.000000000123










10. Sayısal değişkenlerde alt çizgi (underscore) nasıl kullanılır? Kotlin bunu nasıl yorumlar?

Kotlin'de, sayısal değişkenlerde alt çizgi (_) kullanımı, büyük sayıları daha okunabilir hale getirmek için kullanılır.
Alt çizgi, sayının değerini veya işleyişini etkilemez; sadece geliştiricinin sayıyı daha kolay okumasını sağlar. 
Kotlin derleyicisi alt çizgileri göz ardı eder ve sayıyı bir bütün olarak değerlendirir.

val million = 1_000_000
val bytes = 0b1101_0101_0011_1110
val hexBytes = 0xFF_EC_DE_5E
val pi = 3.1415_9265
val creditCardNumber = 1234_5678_9012_3456L

// Hatalı kullanımlar
val invalidNumber1 = _1000  // Hata: Sayı başında alt çizgi olmamalıdır.
val invalidNumber2 = 1000_  // Hata: Sayı sonunda alt çizgi olmamalıdır.










11. == ile neyi karşılaştırırız? === ile neyi karşılaştırırız?

== operatörü, iki değerin eşit olup olmadığını karşılaştırır. Bu operatör, Kotlin'de equals fonksiyonunu çağırarak çalışır. 
Yani, iki nesnenin değerlerini karşılaştırır ve eşitse true, değilse false döner.

=== operatörü ise, iki nesnenin aynı referansa sahip olup olmadığını karşılaştırır. Bu operatör, nesnelerin bellekte aynı yerde olup olmadığını kontrol eder. 
Eğer iki değişken aynı nesneyi işaret ediyorsa true, farklı nesneleri işaret ediyorsa false döner.











12. === operatörü ile karşılaştırma yaparken Byte değer aralığı neden önemlidir? Kotlin bu aralığa göre neden özel bir davranış sergiler?

Kotlin'de === operatörü ile karşılaştırma yaparken, Byte veri tipinin değer aralığı (-128 ile 127 arasında) önemli bir rol oynar. 
Bunun nedeni, Kotlin'in (ve altta yatan JVM'in) bu küçük aralıktaki Byte nesnelerini optimizasyon amacıyla havuzlamasıdır. 
Bu durum, === operatörü ile yapılan karşılaştırmaların sonuçlarını etkileyebilir.
Referans eşitliği === işlemi ve bunun olumsuzlanmış karşılığı !== ile kontrol edilir.

    val number: Int = 127   // int
    val boxedNumber: Int? = number
    val anotherBoxedNumber: Int? = number
    println(boxedNumber === anotherBoxedNumber) // true

    val number2: Int = 128
    val boxedNumber2: Int? = number2
    val anotherBoxedNumber2: Int? = number2
    println(boxedNumber2 === anotherBoxedNumber2) // false

Not: Runtime'da primitive (ilkel) türler tarafından temsil edilen değerler için (örneğin, Int), === eşitlik kontrolü == kontrolüne eşdeğerdir.

    var a = "Hello"
    var b = a
    var c = "world"
    var d = "world"

    println(a === b)  // true
    println(a === c)  // false
    println(c === d)  // true










13. Sayısal değişkenlerde hangi matematiksel operatörler kullanılabilir?

Temel aritmetik operatörler: * / % + - 
Artırma ve azaltma operatörleri: ++ --
Birleştirilmiş operatörler: += -= *= /= %=










14. Sayısal değişkenlerde hangi karşılaştırma operatörleri kullanılabilir?

Karşılaştırma Operatörleri: < > <= >= == !=











15. Bit düzeyinde operatörler (Bitwise operators) nelerdir? Ne amaçla kullanılır? Kotlin'de bunları nasıl kullanabilirsiniz?

Bit düzeyinde operatörler (bitwise operators), ikili (binary) sayı sistemindeki bitlerle işlem yapmamıza olanak tanıyan operatörlerdir. 
Bu operatörler, özellikle düşük seviyeli programlama, performans kritik uygulamalar ve belirli algoritmalar için oldukça kullanışlıdır. 
Bit düzeyinde operatörler genellikle doğrudan bit manipülasyonu, bit maskeleri, şifreleme algoritmaları, veri sıkıştırma ve düşük seviyeli cihaz sürücüsü yazılımı gibi alanlarda kullanılır.

1. Bitwise AND (and)
Bitwise AND operatörü, iki sayının karşılık gelen bitlerini AND işlemi ile karşılaştırır. Sonuç olarak, her iki bit de 1 olduğunda sonuç 1, aksi halde 0 olur.

2. Bitwise OR (or)
Bitwise OR operatörü, iki sayının karşılık gelen bitlerini OR işlemi ile karşılaştırır. Sonuç olarak, herhangi bir bit 1 olduğunda sonuç 1 olur.

3. Bitwise XOR (xor)
Bitwise XOR operatörü, iki sayının karşılık gelen bitlerini XOR işlemi ile karşılaştırır. Sonuç olarak, bitler farklı olduğunda sonuç 1, aynı olduğunda 0 olur.

4. Bitwise NOT (inv)
Bitwise NOT operatörü, tek bir sayının bitlerini tersine çevirir (0'ları 1 yapar, 1'leri 0 yapar).

5. Bitwise Shift Left (shl)
Bitwise Shift Left operatörü, bir sayının bitlerini belirli bir sayı kadar sola kaydırır. Bu, sayının 2'nin kaydırılan sayı kadar kuvveti ile çarpılmasıyla aynıdır.

6. Bitwise Shift Right (shr)
Bitwise Shift Right operatörü, bir sayının bitlerini belirli bir sayı kadar sağa kaydırır. Bu, sayının 2'nin kaydırılan sayı kadar kuvveti ile bölünmesiyle aynıdır.

7. Unsigned Shift Right (ushr)
Unsigned Shift Right operatörü, bir sayının bitlerini sağa kaydırırken işaret bitini dikkate almaz. Bu, negatif sayılar için önemlidir.

    
    val number = -12 // 11111111111111111111111111110100 in binary (32-bit representation)

    val a = 12 // 01100 in binary
    val b = 25 // 11001 in binary

    val resultAnd = a and b
    println(resultAnd) // Output: 8 (01000 in binary)

    val resultOr = a or b
    println(resultOr) // Output: 29 (11101 in binary)

    val resultXor = a xor b
    println(resultXor) // Output: 21 (10101 in binary)

    val resultInv = a.inv()      // a: 00000000000000000000000000001100
    println(resultInv) // Output: -13 (11111111111111111111111111110011 in binary, considering 32-bit representation)

    val resultShl = a shl 2
    println(resultShl) // Output: 48 (110000 in binary)

    val resultShr = a shr 2
    println(resultShr) // Output: 3 (11 in binary)

    val result = number ushr 2
    println(result) // Output: 1073741821 (00111111111111111111111111111101 in binary)











16. Kotlin'de büyük sayılarla çalışırken hangi ek türlerden yararlanılır ve bu türlerin sınırları nelerdir?

Kotlin'de büyük sayılarla çalışırken, BigInteger ve BigDecimal sınıflarından yararlanılır. 
Bu sınıflar, Kotlin standard kütüphanesinin bir parçası değildir, ancak Java standard kütüphanesinden kolayca kullanılabilirler. 

import java.math.BigDecimal  // Sınırsız büyüklükte tam sayılar için.
import java.math.BigInteger  // Yüksek hassasiyetli ondalık sayılar için.

BigInteger ve BigDecimal özelinde, sınırlar JVM'in atadığı belleğe göre değişebilir.